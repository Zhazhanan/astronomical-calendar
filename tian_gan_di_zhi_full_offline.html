<!doctype html>
<html lang="zh">
<head>
<meta charset="utf-8" />
<title>天干·地支·节气·天文学专业版（离线）</title>
<style>
  html,body{height:100%;margin:0;background:#010114;color:#fff;font-family:Arial, Helvetica, sans-serif}
  #ui{
    position:absolute; left:12px; top:12px; width:320px; z-index:30;
    background:rgba(2,8,20,0.72); padding:12px; border-radius:8px; box-shadow:0 8px 20px rgba(0,0,0,0.6)
  }
  #ui h3{margin:0 0 8px 0;font-size:16px}
  #ui label{display:block;margin:6px 0;font-size:13px}
  .btn{background:#2673ff;color:#fff;border:none;padding:6px 10px;border-radius:6px;cursor:pointer;margin-right:6px}
  .small{font-size:12px;color:#bcd;margin-top:6px}
  #credits{position:absolute; right:12px; bottom:12px; color:#9fb; background:rgba(0,0,0,0.28); padding:8px;border-radius:6px; font-size:12px}
  .legend{font-size:12px;color:#cde;margin-top:8px}
</style>
</head>
<body>
<div id="ui">
  <h3>天干·地支·节气 · 天文学版</h3>

  <label>
    <input type="checkbox" id="showEcliptic" checked> 显示黄道
  </label>
  <label>
    <input type="checkbox" id="showEquator" checked> 显示赤道网格
  </label>
  <label>
    <input type="checkbox" id="showGalactic"> 显示银河面（示意）
  </label>

  <label>
    <input type="checkbox" id="showTiangan" checked> 显示天干（10）
    <input type="checkbox" id="showDizhi" checked style="margin-left:8px"> 显示地支（12）
  </label>

  <label>
    <input type="checkbox" id="showJieqi" checked> 显示二十四节气（并显示今天指示）
  </label>
  <label>
    <input type="checkbox" id="show28xiu" checked> 显示二十八宿带（等分示意）
  </label>

  <label>
    <input type="checkbox" id="showJiazi" checked> 显示 60 甲子连线（点击标记可查甲子）
  </label>

  <div style="margin-top:8px">
    <button id="resetView" class="btn">重置视角</button>
    <button id="screenshot" class="btn">导出 PNG</button>
  </div>

  <label style="margin-top:8px">加载本地星表 CSV（可选）：
    <input id="fileInput" type="file" accept=".csv" />
    <div class="small">CSV 列头示例：name,ra_hms,dec_dms,mag （RA format 13:25:11.6 或 13h25m11.6s）</div>
  </label>

  <div class="legend">
    说明：太阳当前黄经（近似）显示为黄色指示器；二十八宿按黄道等分示意投影到天赤道。
  </div>
</div>

<div id="credits">离线版 · 本地 three.min.js + OrbitControls.js</div>

<!-- 请把 three.min.js 与 OrbitControls.js（non-module UMD）放同目录 -->
<script src="./three.min.js"></script>
<script src="./OrbitControls.js"></script>

<script>
/* ========== 全局设置 ========== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x02021a);

const camera = new THREE.PerspectiveCamera(55, window.innerWidth/window.innerHeight, 0.1, 4000);
camera.position.set(0, 140, 360);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(window.devicePixelRatio ? window.devicePixelRatio : 1);
document.body.appendChild(renderer.domElement);

const controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

/* helper groups */
const gridGroup = new THREE.Group(); scene.add(gridGroup);
const eclipticGroup = new THREE.Group(); scene.add(eclipticGroup);
const galacticGroup = new THREE.Group(); scene.add(galacticGroup);
const tgGroup = new THREE.Group(); scene.add(tgGroup);
const dzGroup = new THREE.Group(); scene.add(dzGroup);
const jqGroup = new THREE.Group(); scene.add(jqGroup);
const xiuGroup = new THREE.Group(); scene.add(xiuGroup);
const starGroup = new THREE.Group(); scene.add(starGroup);
const jiaziLinesGroup = new THREE.Group(); scene.add(jiaziLinesGroup);
const indicatorsGroup = new THREE.Group(); scene.add(indicatorsGroup);

/* 常量 */
const R = 140; // sphere radius in scene units
const tilt = 23.439281 * Math.PI/180;

/* small utility */
function makeLabelSprite(text, size=48, color="#ffffff", width=512, height=256){
  const canvas = document.createElement('canvas'); canvas.width=width; canvas.height=height;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = color;
  ctx.font = `${size}px sans-serif`;
  ctx.textAlign = 'center'; ctx.textBaseline='middle';
  ctx.fillText(text, width/2, height/2);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({map:tex, transparent:true});
  const sp = new THREE.Sprite(mat);
  sp.scale.set(size*0.5, size*0.25, 1);
  return sp;
}

/* convert ra/dec (deg) -> cartesian */
function radecToCartesian(raDeg, decDeg, radius=R){
  const ra = raDeg * Math.PI/180;
  const dec = decDeg * Math.PI/180;
  const x = radius * Math.cos(dec) * Math.cos(ra);
  const y = radius * Math.sin(dec);
  const z = radius * Math.cos(dec) * Math.sin(ra);
  return new THREE.Vector3(x,y,z);
}

/* parse hms/dms text to degrees (robustish) */
function parseHMS(hms){
  if(hms==null) return null;
  const s = (''+hms).trim();
  if(s.indexOf('h')!==-1 || s.indexOf(':')!==-1){
    // replace h m s with colon
    const parts = s.replace(/[hms]/g,':').replace(/\s+/g,':').split(':').filter(Boolean);
    const h = parseFloat(parts[0])||0, m = parseFloat(parts[1])||0, sec = parseFloat(parts[2])||0;
    return (h + m/60 + sec/3600) * 15;
  } else {
    // assume decimal degrees
    const v = parseFloat(s);
    if(isNaN(v)) return null;
    return v;
  }
}
function parseDMS(dms){
  if(dms==null) return null;
  const s = (''+dms).trim();
  const sign = s.startsWith('-') ? -1 : 1;
  const parts = s.replace(/[°d'"]/g,':').replace(/[m\s]+/g,':').replace(/[hms]/g,':').split(':').filter(Boolean);
  const d = parseFloat(parts[0])||0, m = parseFloat(parts[1])||0, sec = parseFloat(parts[2])||0;
  return sign * (Math.abs(d) + (m/60) + (sec/3600));
}

/* draw sky sphere wireframe */
(function(){
  const geo = new THREE.SphereGeometry(R, 64, 32);
  const mat = new THREE.MeshBasicMaterial({color:0x0b1220, wireframe:true, opacity:0.06, transparent:true});
  const mesh = new THREE.Mesh(geo, mat);
  scene.add(mesh);
})();

/* equatorial grid (RA/Dec) */
function buildEquatorialGrid(){
  const g = new THREE.Group();
  const mat = new THREE.LineBasicMaterial({color:0x2a6fab, transparent:true, opacity:0.45});
  const lonLines = 24;
  for(let i=0;i<lonLines;i++){
    const lon = i / lonLines * 360;
    const pts = [];
    for(let dec=-80; dec<=80; dec+=2){
      const v = radecToCartesian(lon, dec, R);
      pts.push(v.x, v.y, v.z);
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(pts, 3));
    g.add(new THREE.Line(geom, mat));
  }
  // latitude circles (dec)
  for(let dec=-60; dec<=60; dec+=30){
    const pts=[];
    for(let lon=0; lon<360; lon+=2){
      const v = radecToCartesian(lon, dec, R);
      pts.push(v.x, v.y, v.z);
    }
    const geom = new THREE.BufferGeometry();
    geom.setAttribute('position', new THREE.Float32BufferAttribute(pts,3));
    g.add(new THREE.Line(geom, mat));
  }
  return g;
}
gridGroup.add(buildEquatorialGrid());

/* ecliptic ring (constructed in ecliptic coords then rotated into equatorial via tilt) */
(function buildEcliptic(){
  const pts=[];
  for(let L=0; L<360; L+=1){
    const lon = THREE.Math.degToRad(L);
    // ecliptic coords on unit circle in XY plane, then rotate about X by tilt to equatorial
    const x = Math.cos(lon);
    const y = Math.sin(lon) * Math.cos(tilt);
    const z = Math.sin(lon) * Math.sin(tilt);
    pts.push(x*R, y*R, z*R);
  }
  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(pts,3));
  const mat = new THREE.LineDashedMaterial({color:0xffb86b, dashSize:3, gapSize:2, linewidth:1});
  const line = new THREE.Line(geom, mat); line.computeLineDistances();
  eclipticGroup.add(line);
})();

/* galactic plane (illustrative) */
(function buildGalactic(){
  const tiltG = 60 * Math.PI/180;
  const pts=[];
  for(let L=0; L<360; L+=1){
    const lon = THREE.Math.degToRad(L);
    const x = Math.cos(lon);
    const y = Math.sin(lon) * Math.cos(tiltG);
    const z = Math.sin(lon) * Math.sin(tiltG);
    pts.push(x*R, y*R, z*R);
  }
  const geom = new THREE.BufferGeometry();
  geom.setAttribute('position', new THREE.Float32BufferAttribute(pts,3));
  const mat = new THREE.LineBasicMaterial({color:0x9f8fff, opacity:0.28, transparent:true});
  const line = new THREE.Line(geom, mat);
  galacticGroup.add(line);
})();
galacticGroup.visible = false;

/* draw 24 solar terms around ecliptic, and show current date indicator (approx) */
const jieqi = [
 '立春','雨水','惊蛰','春分','清明','谷雨',
 '立夏','小满','芒种','夏至','小暑','大暑',
 '立秋','处暑','白露','秋分','寒露','霜降',
 '立冬','小雪','大雪','冬至','小寒','大寒'
];
(function buildJieqi(){
  const r = R * 0.92;
  for(let i=0;i<24;i++){
    const ang = i/24 * Math.PI*2;
    // place on ecliptic param then rotated to eq coords
    const x = Math.cos(ang);
    const y = Math.sin(ang) * Math.cos(tilt);
    const z = Math.sin(ang) * Math.sin(tilt);
    const pos = new THREE.Vector3(x*r, y*r, z*r);
    const sp = makeLabelSprite(jieqi[i], 24, "#ffd38a");
    sp.position.copy(pos);
    jqGroup.add(sp);
  }
})();
jqGroup.visible = true;

/* compute approximate solar longitude for given date:
   approx method: take day-of-year relative to Mar 20 as 0° and map linearly across 365.2422 days.
   (This is approximate but serviceable for visualization.)
*/
function solarLongitudeApprox(date){
  // date: JS Date in local or UTC -- use UTC to avoid timezone artifacts
  const year = date.getUTCFullYear();
  // spring equinox approx: March 20
  const equinox = new Date(Date.UTC(year, 2, 20, 0, 0, 0)); // Mar 20 UTC
  const msPerDay = 86400000;
  const days = (date.getTime() - equinox.getTime()) / msPerDay;
  const daysInYear = 365.2422;
  const frac = (days / daysInYear);
  let lon = (frac * 360) % 360;
  if(lon < 0) lon += 360;
  return lon;
}

/* indicator for Sun position */
function buildSunIndicator(){
  const lonDeg = solarLongitudeApprox(new Date());
  // compute ecliptic position (unit) at lonDeg then rotate to eq coords
  const lon = THREE.Math.degToRad(lonDeg);
  const x = Math.cos(lon);
  const y = Math.sin(lon)*Math.cos(tilt);
  const z = Math.sin(lon)*Math.sin(tilt);
  const pos = new THREE.Vector3(x*R*0.98, y*R*0.98, z*R*0.98);
  const sunMat = new THREE.MeshBasicMaterial({color:0xffd24d});
  const sun = new THREE.Mesh(new THREE.SphereGeometry(4.5, 12, 8), sunMat);
  sun.position.copy(pos);
  indicatorsGroup.add(sun);
  const label = makeLabelSprite('太阳 (近似黄经 '+lonDeg.toFixed(1)+'°)', 20, '#ffd24d');
  label.position.copy(pos.clone().multiplyScalar(1.08));
  indicatorsGroup.add(label);
  // small radial line to ecliptic
  const lnGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), pos]);
  const ln = new THREE.Line(lnGeom, new THREE.LineBasicMaterial({color:0xffd24d, opacity:0.6}));
  indicatorsGroup.add(ln);
}
buildSunIndicator();

/* 天干 / 地支 环 */
const tiangan = ["甲","乙","丙","丁","戊","己","庚","辛","壬","癸"];
const dizhi = ["子","丑","寅","卯","辰","巳","午","未","申","酉","戌","亥"];
(function buildTG_DZ(){
  const r1 = R * 0.45, r2 = R * 0.65;
  tiangan.forEach((t,i)=>{
    const ang = i/10 * Math.PI*2 - Math.PI/2;
    const sp = makeLabelSprite(t, 36, "#8fffb3");
    sp.position.set(Math.cos(ang)*r1, -22, Math.sin(ang)*r1);
    tgGroup.add(sp);
  });
  dizhi.forEach((d,i)=>{
    const ang = i/12 * Math.PI*2 - Math.PI/2;
    const sp = makeLabelSprite(d, 32, "#8fbffd");
    sp.position.set(Math.cos(ang)*r2, -32, Math.sin(ang)*r2);
    dzGroup.add(sp);
  });
})();
tgGroup.visible = true; dzGroup.visible = true;

/* 二十八宿带 （等分黄道然后投影到赤道） */
const xiuNames = ["角","亢","氐","房","心","尾","箕","斗","牛","女","虚","危","室","壁","奎","娄","胃","昴","毕","觜","参","井","鬼","柳","星","张","翼","轸"];
(function build28xiu(){
  const r = R * 0.98;
  for(let i=0;i<28;i++){
    const ang = i/28 * Math.PI*2;
    const x = Math.cos(ang);
    const y = Math.sin(ang) * Math.cos(tilt);
    const z = Math.sin(ang) * Math.sin(tilt);
    const pos = new THREE.Vector3(x*r, y*r, z*r);
    const sp = makeLabelSprite(xiuNames[i], 18, "#ffccaa");
    sp.position.copy(pos);
    xiuGroup.add(sp);
  }
})();
xiuGroup.visible = true;

/* 60 甲子连线：按序 (0..59) 甲[ i%10 ] + 乙? actually mapping is tgIndex=i%10, dzIndex=i%12 */
(function buildJiaziLines(){
  jiaziLinesGroup.clear && jiaziLinesGroup.clear(); // if exists
  const combos = [];
  for(let i=0;i<60;i++){
    const tgIdx = i % 10;
    const dzIdx = i % 12;
    combos.push({i, tgIdx, dzIdx});
  }
  // create lines connecting tg position to dz position
  combos.forEach((c, idx)=>{
    const angleTG = c.tgIdx/10 * Math.PI*2 - Math.PI/2;
    const posTG = new THREE.Vector3(Math.cos(angleTG)*R*0.45, -22, Math.sin(angleTG)*R*0.45);
    const angleDZ = c.dzIdx/12 * Math.PI*2 - Math.PI/2;
    const posDZ = new THREE.Vector3(Math.cos(angleDZ)*R*0.65, -32, Math.sin(angleDZ)*R*0.65);
    // mid point marker for interaction
    const mid = posTG.clone().add(posDZ).multiplyScalar(0.5);
    const lineGeom = new THREE.BufferGeometry().setFromPoints([posTG, posDZ]);
    const lineMat = new THREE.LineBasicMaterial({color:0x88ffbb, opacity:0.6});
    const line = new THREE.Line(lineGeom, lineMat);
    jiaziLinesGroup.add(line);
    // marker sphere
    const sph = new THREE.Mesh(new THREE.SphereGeometry(1.8,8,6), new THREE.MeshBasicMaterial({color:0xffff88}));
    sph.position.copy(mid);
    // label = combo name like "甲子" etc.
    const tgChar = tiangan[c.tgIdx], dzChar = dizhi[c.dzIdx];
    sph.userData = { name: tgChar + dzChar, idx: idx };
    jiaziLinesGroup.add(sph);
    // optional tiny label sprite
    const lab = makeLabelSprite(tgChar+dzChar, 12, "#ffeeaa");
    lab.position.copy(mid.clone().add(new THREE.Vector3(0,6,0)));
    jiaziLinesGroup.add(lab);
  });
})();
jiaziLinesGroup.visible = true;

/* 点击交互：点击甲子标记弹窗 */
const ray = new THREE.Raycaster();
const mouse = new THREE.Vector2();
renderer.domElement.addEventListener('pointerdown', (ev)=>{
  mouse.x = (ev.clientX / renderer.domElement.clientWidth) * 2 - 1;
  mouse.y = -(ev.clientY / renderer.domElement.clientHeight) * 2 + 1;
  ray.setFromCamera(mouse, camera);
  const intersects = ray.intersectObjects(jiaziLinesGroup.children, true);
  if(intersects.length>0){
    const ob = intersects[0].object;
    if(ob.userData && ob.userData.name){
      alert('六十甲子：' + ob.userData.name + '\\n序号 (0=甲子): ' + ob.userData.idx);
    }
  }
  // click star points if any
  const sints = ray.intersectObjects(starGroup.children, true);
  if(sints.length>0){
    const o = sints[0].object;
    if(o.userData && o.userData.name){
      alert('恒星：' + o.userData.name + '\\nRA: ' + (o.userData.raDeg||'—') + '\\nDec: ' + (o.userData.decDeg||'—') + '\\nMag: ' + (o.userData.mag||'—'));
    }
  }
});

/* load local CSV into starGroup (optional) */
document.getElementById('fileInput').addEventListener('change', (ev)=>{
  const f = ev.target.files[0]; if(!f) return;
  const reader = new FileReader();
  reader.onload = (e) => {
    const txt = e.target.result;
    parseCSVStars(txt);
  };
  reader.readAsText(f, 'utf-8');
});
function parseCSVStars(txt){
  starGroup.clear && starGroup.clear();
  const lines = txt.split(/\\r?\\n/).filter(l=>l.trim());
  // detect header
  let start=0, hdr = lines[0].split(',').map(h=>h.trim().toLowerCase());
  if(hdr.includes('name') && (hdr.includes('ra_hms')||hdr.includes('ra'))){
    start = 1;
  } else start = 0;
  for(let i=start;i<lines.length;i++){
    const cols = lines[i].split(',').map(c=>c.trim());
    if(cols.length < 2) continue;
    const name = cols[0];
    const ra = parseHMS(cols[1]);
    const dec = parseDMS(cols[2]||cols[1]);
    const mag = parseFloat(cols[3]||'9.9');
    if(ra==null || dec==null) continue;
    const pos = radecToCartesian(ra, dec, R*0.995);
    const dot = new THREE.Mesh(new THREE.SphereGeometry(Math.max(0.8,4 - mag/2), 8,6), new THREE.MeshBasicMaterial({color:0xffffff}));
    dot.position.copy(pos);
    dot.userData = {name, raDeg:ra, decDeg:dec, mag};
    starGroup.add(dot);
    const lab = makeLabelSprite(name, 12, '#fff');
    lab.position.copy(pos.clone().multiplyScalar(1.02));
    starGroup.add(lab);
  }
}

/* UI toggles wiring */
document.getElementById('showEcliptic').addEventListener('change', (e)=> eclipticGroup.visible = e.target.checked );
document.getElementById('showEquator').addEventListener('change', (e)=> gridGroup.visible = e.target.checked );
document.getElementById('showGalactic').addEventListener('change', (e)=> galacticGroup.visible = e.target.checked );
document.getElementById('showTiangan').addEventListener('change', (e)=> tgGroup.visible = e.target.checked );
document.getElementById('showDizhi').addEventListener('change', (e)=> dzGroup.visible = e.target.checked );
document.getElementById('showJieqi').addEventListener('change', (e)=> jqGroup.visible = e.target.checked );
document.getElementById('show28xiu').addEventListener('change', (e)=> xiuGroup.visible = e.target.checked );
document.getElementById('showJiazi').addEventListener('change', (e)=> jiaziLinesGroup.visible = e.target.checked );

/* screenshot & reset */
document.getElementById('resetView').addEventListener('click', ()=>{
  camera.position.set(0,140,360); controls.target.set(0,0,0);
});
document.getElementById('screenshot').addEventListener('click', ()=>{
  renderer.render(scene, camera);
  const url = renderer.domElement.toDataURL('image/png');
  const a = document.createElement('a'); a.href = url; a.download = 'tianwen_snapshot.png'; a.click();
});

/* animate */
function animate(){
  requestAnimationFrame(animate);
  // slight rotation for visibility
  tgGroup.rotation.y += 0.0006;
  dzGroup.rotation.y -= 0.0004;
  jqGroup.rotation.y += 0.0002;
  controls.update();
  renderer.render(scene, camera);
}
animate();

/* resize */
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

</script>
</body>
</html>
